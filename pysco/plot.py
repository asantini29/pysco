# -*- coding: utf-8 -*-

from functools import wraps
from importlib.machinery import SourceFileLoader
import os
import warnings
from shutil import which as find_executable

import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.colors import to_rgba
from matplotlib import ticker
from cycler import cycler

import numpy as np
import pandas as pd

try:
    import chainconsumer
    chain_here = True
except:
    warnings.warn('WARNING: ChainConsumer not found. chainplot will not work.')
    chain_here = False


try: 
    pysco_file = str(__file__)
    corner_file = os.getenv('CORNER_PATH') + '/src/corner/__init__.py'
    
    c = SourceFileLoader('corner', corner_file).load_module() #custom version of corner, allow to choose the color of the quantiles
except:
    import corner as c
    warnings.warn('WARNING: imported standard corner.py')

    __all__ = [
        'which_corner',
        'check_latex',
        'default_plotting',
        'reset_rc',
        'set_ticker',
        'custom_corner',
        'corner',
        'set_color_cycle_from_cmap',
        'get_colors_from_cmap',
        'custom_color_cycle',
        'get_colorslist',
        'to_pandas',
        'chainplot'
    ]


#---- Plotting Stuff ----#

def which_corner():
    print('You are using the corner package located at' + str(corner.__file__))

def check_latex():
    if find_executable('latex'):
        mpl.rcParams['text.usetex']=True
        return
    else:
         mpl.rcParams['text.usetex']=False
         return

def default_plotting(style='light', backcolor=None, frontcolor=None):
    """
    Set the default plotting parameters for matplotlib.

    Parameters:
    - style (str): The style of the plot. Can be 'light', 'dark'. Default is 'light'.
    - backcolor (str): The background color of the plot. Default is 'white'.
    - frontcolor (str): The foreground color of the plot. Default is 'black'.
    """

    default_rcParams = {
        'text.usetex': True,
        'font.family': 'serif',
        'font.weight':'medium',
        'mathtext.fontset': 'cm',
        'text.latex.preamble': r"\usepackage{amsmath}",
        'font.size': 20,
        'figure.figsize': (7, 7),
        'figure.titlesize': 22,
        'axes.formatter.use_mathtext': True,
        'axes.formatter.limits': [-2, 4],
        'axes.titlesize': 22,
        'axes.labelsize': 22,
        'xtick.top': True,
        'xtick.major.size': 5,
        'xtick.minor.size': 3,
        'xtick.major.width': 0.8,
        'xtick.minor.visible': True,
        'xtick.direction': 'in',
        'xtick.labelsize': 20,
        'ytick.right': True,
        'ytick.major.size': 5,
        'ytick.minor.size': 3,
        'ytick.major.width': 0.8,
        'ytick.minor.visible': True,
        'ytick.direction': 'in',
        'ytick.labelsize': 20,
        'legend.frameon': True,
        'legend.framealpha': 1,
        'legend.fontsize': 20,
        'legend.scatterpoints' : 3,
        #'lines.color': 'k',
        'lines.linewidth': 2,
        'patch.linewidth': 1,
        'hatch.linewidth': 1,
        'grid.linestyle': 'dashed',
        'savefig.dpi' : 200,
        'savefig.format' : 'pdf',
        'savefig.bbox' : 'tight',
        'savefig.transparent' : True,
    }

    plt.rcParams.update(default_rcParams)

    if style == 'light':
        set_colors(backcolor='white', frontcolor='black')
    elif style == 'dark':
        set_colors(backcolor='none', frontcolor='white')
        mpl.rcParams['savefig.format'] = 'png'
    else:
        set_colors(backcolor=backcolor, frontcolor=frontcolor)

    custom_color_cycle()
    check_latex()

def set_colors(backcolor='white', frontcolor='black'):
    """
    Set the colors for the plot.

    Parameters:
    - backcolor (str): The background color of the plot. Default is 'white'.
    - frontcolor (str): The foreground color of the plot. Default is 'black'.
    """

    mpl.rcParams['text.color'] = frontcolor
    mpl.rcParams['axes.labelcolor'] = frontcolor
    mpl.rcParams['axes.edgecolor'] = frontcolor
    mpl.rcParams['xtick.color'] = frontcolor
    mpl.rcParams['ytick.color'] = frontcolor
    mpl.rcParams['axes.facecolor'] = backcolor
    mpl.rcParams['figure.facecolor'] = backcolor
    mpl.rcParams['legend.facecolor'] = backcolor
    #mpl.rcParams['legend.edgecolor'] = frontcolor
    mpl.rcParams['axes.titlecolor'] = frontcolor
    mpl.rcParams['legend.labelcolor'] = frontcolor
    mpl.rcParams['grid.color'] = frontcolor
    mpl.rcParams['lines.color'] = frontcolor

def reset_rc():
    mpl.rcParams.update(mpl.rcParamsDefault)

def set_ticker():
    ticker.ScalarFormatter(useMathText=plt.rcParams['text.usetex'])

def custom_corner(function):
    """
    A decorator function that customizes the corner plot generated by the input function.

    Parameters:
    - function: The function that generates the corner plot.

    Returns:
    - The customized corner plot.

    Usage:
    @custom_corner
    def generate_corner_plot(*args, **kwargs):
        # Code to generate the corner plot

    Example:
    generate_corner_plot(data, labels=['x', 'y', 'z'], color='blue', save=True, filename='corner_plot.png')
    """
    
    @wraps(function)
    def wrapper(*args, **kwargs):
        """
        A wrapper function that customizes matplotlib settings and calls the specified function with the given arguments.

        Parameters:
        *args: positional arguments to be passed to the specified function.
        **kwargs: keyword arguments to be passed to the specified function.

        Returns:
        fig: the figure object returned by the specified function.

        Raises:
        None.
        """

        corner_rcParams = {
            'xtick.top': False,
            'xtick.major.size': 3.5,
            #'xtick.major.width': 1.,
            'xtick.minor.visible': False,
            'xtick.direction': 'out',
            'ytick.right': False,
            'ytick.major.size': 3.5,
            #'ytick.major.width': 1.,
            'ytick.minor.visible': False,
            'ytick.direction': 'out',
            'ytick.labelsize': 20,
            'lines.linewidth': 1.5,
            }
        
        backcolor = plt.rcParams['figure.facecolor']
        frontcolor = plt.rcParams['text.color']

        # customize matplotlib
        if 'custom_rc' in kwargs.keys():
            custom_rc = kwargs.pop('custom_rc')
        else:
            custom_rc = True
        if custom_rc:
            plt.rcParams.update(corner_rcParams)

        if 'rcParams' in kwargs.keys():
            rcParams = kwargs.pop('rcParams')
            plt.rcParams.update(rcParams)

        defaults_kwargs = dict(
            bins=50, 
            smooth=0.5,
            title_kwargs=dict(fontsize=16), 
            color='#3f90da',
            truth_color=frontcolor,
            quantiles=[0.05, 0.5, 0.95],
            linestyle='-',
            plot_median=False,
            marginal_type='hist',
            quantiles_color=None, 
            show_titles = True, 
            title_fmt='.2e',
            levels=(1 - np.exp(-0.5), 1 - np.exp(-2), 1 - np.exp(-9 / 2.)),
            plot_density=False, 
            plot_datapoints=False, 
            fill_contours=True,
            max_n_ticks=5, 
            use_math_text=True, 
            custom_whspace=0.05,
        )

        
        _kwargs = kwargs.copy()
        
        save = False
        if 'save' in kwargs.keys():
            #save = True
            save = kwargs.pop('save')
            try:
                filename = kwargs.pop('filename')
            except:
                print('"filename" not provided, defaulted to cornerplot.pdf')
                filename = './cornerplot'

        hist_kwargs = dict(
                    histtype = _kwargs['histtype'] if 'histtype' in _kwargs.keys() else 'step',
                    edgecolor = _kwargs['color'] if 'color' in _kwargs.keys() else defaults_kwargs['color'],
                    lw = 1.5,
                    density=True, 
                )
        
        keys = _kwargs.keys()
        for key in keys:
            if key in defaults_kwargs.keys():
                defaults_kwargs.pop(key)

            if key in hist_kwargs.keys():
                hist_kwargs[key] = kwargs.pop(key)
            
        alpha = _kwargs['histalpha'] if 'histalpha' in _kwargs.keys() else 0.1
        defaults_kwargs.update(kwargs)
        fc = to_rgba(defaults_kwargs['color'], alpha=alpha)
        hist_kwargs['fc'] = fc
        defaults_kwargs['hist_kwargs'] = hist_kwargs
        kwargs = defaults_kwargs

        fig = function(*args, **kwargs)

        if save:
            fig.savefig(filename)
        
        default_plotting(backcolor=backcolor, frontcolor=frontcolor)

        return fig

    return wrapper

@custom_corner
def corner(*args, **kwargs):
    fig =  c.corner(*args, **kwargs)
    return fig

def set_color_cycle_from_cmap(cmap=None):
    '''
    use custom colormap as standard colorcycle. 
    '''
    if cmap:
        plt.rcParams["axes.prop_cycle"] = plt.cycler("color", cmap.colors)
    else:
         plt.rcParams["axes.prop_cycle"] =  plt.rcParamsDefault["axes.prop_cycle"]
    
def get_colors_from_cmap(N, cmap='viridis', reverse=False):
    cmap = mpl.colormaps[cmap]
    colors = cmap(np.linspace(0.3, 1., N))
    if reverse:
        colors = colors[::-1]
    return colors

def custom_color_cycle(colors='colors6', linestyles=['-'], skip=0, lsfirst=False):
    '''
    setup a custom matplotlib color cycler.
    `colors6`, `colors8`, `colors10` refer to the results of arXiv:2107.02270.
    `fancy` contains a color palette I like (still work in progress).
    '''

    baselinestyles = ['-', '--', '-.', ':']

    if isinstance(colors, str):
        colors = get_colorslist(colors)

    elif isinstance(colors, list):
        pass
    else:
        raise ValueError('provide `colors` as a list of color IDs or a key of `basecolors`')
    
    if isinstance(linestyles, int):
        linestyles = baselinestyles[:linestyles]
    
    if colors is not None:
        if lsfirst:
            mycycler = cycler(color=colors[skip:]) * cycler(linestyle=linestyles)
        else:
            mycycler = cycler(linestyle=linestyles) * cycler(color=colors[skip:])

        plt.rcParams["axes.prop_cycle"] =  mycycler
    
    else:
        plt.rcParams["axes.prop_cycle"] =  plt.rcParamsDefault["axes.prop_cycle"]


def get_colorslist(colors='colors6'):
    basecolors = {
        'colors6': ["#5790fc", "#f89c20", "#e42536", "#964a8b", "#9c9ca1", "#7a21dd"],
        'colors8': ["#1845fb", "#ff5e02", "#c91f16", "#c849a9", "#adad7d", "#86c8dd", "#578dff", "#656364"],
        'colors10': ["#3f90da", "#ffa90e", "#bd1f01", "#94a4a2", "#832db6", "#a96b59", "#e76300", "#b9ac70", "#717581", "#92dadd"],
        'fancy': ['#1c161c', '#324b58', '#088395', '#8ac5ad', '#a1f5a8']
    }

    assert colors in basecolors.keys()
    return basecolors[colors]


def to_pandas(samples, labels):
    """
    Converts the samples to a pandas DataFrame.

    Parameters:
    - samples (array): The samples to convert.
    - labels (list): The labels for the samples.

    Returns:
    - df (DataFrame): The samples as a pandas DataFrame.
    """
    df = pd.DataFrame(samples, columns=labels)
    return df

def chainplot(dfs, names=None, columns=None, truths=None, colors=None, plot_dir='./', savename=None, ls=None, offset=True, padding=1.0, chain_kwargs={}, chainconfig_kwargs={}, legend_kwargs={}, plotconfig_kwargs={}):
    """
    Plots MCMC chains using ChainConsumer.
    Parameters:
    -----------
    dfs : list or dict
        List or dictionary of dataframes containing MCMC samples.
    names : list, optional
        List of names for each chain. If `dfs` is a dictionary, keys are used as names.
    columns : int or list, optional
        Columns to be used for plotting. If None, all columns are used. If int, first `columns` columns are used.
        If list, specific columns are used. If list of lists, different columns for each chain.
    truths : list, optional
        List of true values to be plotted as reference lines.
    colors : str or list, optional
        Color(s) for the chains. If None, default colors are used. If str, a color name / hex code or the name of a colorlist.
    plot_dir : str, optional
        Directory to save the plot. Default is current directory.
    savename : str, optional
        Name of the file to save the plot. If None, plot is not saved.
    ls : str, optional
        Line style for the chains. If None, default styles are used.
    offset : bool, optional
        Whether to offset the plot. Default is True.
    padding : float or tuple, optional
        Padding between labels and ticks. Default is 1.0.
    chain_kwargs : dict, optional
        Additional keyword arguments for ChainConsumer.Chain.
    chainconfig_kwargs : dict, optional
        Additional keyword arguments for ChainConsumer.ChainConfig.
    legend_kwargs : dict, optional
        Additional keyword arguments for the legend.
    plotconfig_kwargs : dict, optional
        Additional keyword arguments for ChainConsumer.PlotConfig.
    Returns:
    --------
    C : ChainConsumer
        ChainConsumer object containing the chains.
    fig : matplotlib.figure.Figure
        Figure object containing the plot.
    """


    if not isinstance(dfs, list):
        
        if isinstance(dfs, dict):
            names = list(dfs.keys())
            dfs = list(dfs.values())
        else:
            names = [names] if isinstance(names, str) else ["Chain"]
            dfs = [dfs]
    
    else:
        if names is None:
            names = [f"Chain {i}" for i in range(len(dfs))]
        else:
            assert len(names) == len(dfs), "Number of names must match number of chains"
        
    n_chains = len(dfs)

    lss = ["-", "--", "-.", ":"] if ls is None else [ls] * n_chains
    my_colorlists = ['colors6', 'colors8', 'colors10']

    if colors is None:
        colorstring = 'colors6'
        colors = get_colorslist(colors=colorstring) #TODO add flexibility for colors
    elif isinstance(colors, str):
        if colors in my_colorlists:
            colorstring = colors
            colors = get_colorslist(colors=colorstring)
        else:
            # assume colors is a single color
            colors = [colors] * n_chains

    while n_chains > len(colors):
        #locate
        idx_now = my_colorlists.index(colorstring)
        if idx_now < len(my_colorlists) - 1:
            colorstring = my_colorlists[idx_now + 1]
            colors = get_colorslist(colors=colorstring)
        else:
            #restore default matplotlib color cycle
            colors = get_colors_from_cmap(n_chains, cmap='gist_rainbow')
    while n_chains > len(lss):
        lss = lss + lss
    
    fontsize = mpl.rcParams['font.size']
    ticksize = mpl.rcParams['xtick.labelsize']
    offset_fontsize = ticksize# + 2

    C = chainconsumer.ChainConsumer()

    for i, name, df in zip(range(n_chains), names, dfs):

        if columns is None:
            columns_here = df.columns
        elif isinstance(columns, int):
            columns_here = df.columns[:columns]
        elif isinstance(columns, list):
            if isinstance(columns[0], list):
                # different columns for each chain
                columns_here = columns[i]
            else:
                # same columns for all chains
                columns_here = columns
        else:
            raise ValueError("columns must be None, int or list")


        chain = chainconsumer.Chain(samples=df[columns_here], name=name, linewidth=2.0, color=colors[i], linestyle=lss[i], **chain_kwargs)
        C.add_chain(chain)

    if truths is not None:
        C.add_truth(chainconsumer.Truth(location=truths, color=mpl.rcParams['text.color'], line_style="-", name="True Values"))
    #c.add_marker(location=df_truths[plotting_columns[:-1]], color='k', marker_style='x', marker_size=20, name="Injection")

    default_chain_kwargs = {
        "sigmas":[0, 1, 2],
        "shade_gradient": 1,
        "shade_alpha": 0.5,
        "statistics": "cumulative",
        "summary_area": 0.90,
    }

    chainconfig_kwargs = default_chain_kwargs | chainconfig_kwargs

    default_legend_kwargs = {
        "labelspacing": 0.8,
        "loc": "center left",
        "frameon": True,
        "fontsize": fontsize,
        "handlelength": 1.5,
        "handletextpad": 0.5,
        "borderaxespad": 0.0,
        }
    
    legend_kwargs = default_legend_kwargs | legend_kwargs
    
    default_plot_kwargs = {
        "summarise": True,
        "tick_font_size": ticksize,
        "label_font_size": fontsize,
        "summary_font_size": fontsize,
        "contour_label_font_size": fontsize,
        "diagonal_tick_labels": True,
        "spacing":None,
        "usetex": True,
        "serif": True,
        "dpi": 300,
        "legend_kwargs": legend_kwargs,
        "legend_color_text": False,
        "show_legend": True,
    }

    plotconfig_kwargs = default_plot_kwargs | plotconfig_kwargs

    C.set_override(chainconsumer.ChainConfig(**chainconfig_kwargs))
    C.set_plot_config(chainconsumer.PlotConfig(**plotconfig_kwargs))

    fig = C.plotter.plot(offset=offset)
    axes = fig.get_axes()
    # format_ticks(axes)

    for i, ax in enumerate(axes):
        # Use ScalarFormatter for scientific notation. format everything to 1 decimal place
        ax.xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True, useOffset=True))
        ax.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True, useOffset=True))

        #isnegative = ax.get_xticks()[0] < 0
        offset_amount = 0.3 #if isnegative else 1.3
        x_offset = ax.xaxis.get_offset_text()
        x_offset.set_x(1.)  # Fine-tune as needed
        x_offset.set_y(-offset_amount)  # Move below the axis
        # set fontsize
        x_offset.set_fontsize(offset_fontsize)

        # Adjust offset text position for y-axis
        y_offset = ax.yaxis.get_offset_text()
        y_offset.set_fontsize(offset_fontsize)

        # Increase padding between labels and ticks
        if isinstance(padding, float):
            xpad = padding
            ypad = padding
        else:
            xpad, ypad = padding
        ax.xaxis.set_label_coords(0.5, -0.2*xpad)  # Adjust label position manually
        ax.yaxis.set_label_coords(-0.2*ypad, 0.5)


    

    #plt.tight_layout()
    if savename is not None:
        plt.savefig(plot_dir + savename)
        plt.close()
    # else:
    #     plt.show()

    return C, fig