# -*- coding: utf-8 -*-

from functools import wraps
from importlib.machinery import SourceFileLoader
import os
import warnings
from distutils.spawn import find_executable

import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.colors import to_rgba
from matplotlib import ticker
from cycler import cycler

import numpy as np
import pandas as pd

try:
    import chainconsumer
    chain_here = True
except:
    warnings.warn('WARNING: ChainConsumer not found. chainplot will not work.')
    chain_here = False


try: 
    pysco_file = str(__file__)
    corner_file = os.getenv('CORNER_PATH') + '/src/corner/__init__.py'
    
    c = SourceFileLoader('corner', corner_file).load_module() #custom version of corner, allow to choose the color of the quantiles
except:
    import corner as c
    warnings.warn('WARNING: imported standard corner.py')

    __all__ = [
        'which_corner',
        'check_latex',
        'default_plotting',
        'reset_rc',
        'set_ticker',
        'custom_corner',
        'corner',
        'set_color_cycle_from_cmap',
        'get_colors_from_cmap',
        'custom_color_cycle',
        'get_colorslist',
        'to_pandas',
        'chainplot'
    ]


#---- Plotting Stuff ----#

def which_corner():
    print('You are using the corner package located at' + str(corner.__file__))

def check_latex():
    if find_executable('latex'):
        mpl.rcParams['text.usetex']=True
        return
    else:
         mpl.rcParams['text.usetex']=False
         return

def default_plotting(backcolor='white', frontcolor='black'):
    """
    Set the default plotting parameters for matplotlib.

    Parameters:
    - backcolor (str): The background color of the plot. Default is 'white'.
    - frontcolor (str): The foreground color of the plot. Default is 'black'.
    """

    default_rcParams = {
        'text.usetex': True,
        'font.family': 'serif',
        'font.serif': 'cmr10',
        'font.weight':'medium',
        'mathtext.fontset': 'cm',
        'text.latex.preamble': r"\usepackage{amsmath}",
        'font.size': 16,
        'figure.figsize': (7, 7),
        'figure.titlesize': 'large',
        'axes.formatter.use_mathtext': True,
        'axes.formatter.limits': [-2, 4],
        'axes.titlesize': 'large',
        'axes.labelsize': 'large',
        'xtick.top': True,
        'xtick.major.size': 5,
        'xtick.minor.size': 3,
        'xtick.major.width': 0.8,
        'xtick.minor.visible': True,
        'xtick.direction': 'in',
        'xtick.labelsize': 'medium',
        'ytick.right': True,
        'ytick.major.size': 5,
        'ytick.minor.size': 3,
        'ytick.major.width': 0.8,
        'ytick.minor.visible': True,
        'ytick.direction': 'in',
        'ytick.labelsize': 'medium',
        'legend.frameon': True,
        'legend.framealpha': 1,
        'legend.fontsize': 'medium',
        'legend.scatterpoints' : 3,
        #'lines.color': 'k',
        'lines.linewidth': 2,
        'patch.linewidth': 1,
        'hatch.linewidth': 1,
        'grid.linestyle': 'dashed',
        'savefig.dpi' : 200,
        'savefig.format' : 'pdf',
        'savefig.bbox' : 'tight',
        'savefig.transparent' : True,
    }
    
    # adjust colors
    default_rcParams['text.color'] = frontcolor
    default_rcParams['axes.labelcolor'] = frontcolor
    default_rcParams['axes.edgecolor'] = frontcolor
    default_rcParams['xtick.color'] = frontcolor
    default_rcParams['ytick.color'] = frontcolor
    default_rcParams['axes.facecolor'] = backcolor
    default_rcParams['figure.facecolor'] = backcolor
    default_rcParams['legend.facecolor'] = backcolor
    #default_rcParams['legend.edgecolor'] = frontcolor
    default_rcParams['legend.labelcolor'] = frontcolor
    default_rcParams['grid.color'] = frontcolor
    default_rcParams['lines.color'] = frontcolor

    plt.rcParams.update(default_rcParams)

    custom_color_cycle()
    check_latex()

def reset_rc():
    mpl.rcParams.update(mpl.rcParamsDefault)

def set_ticker():
    ticker.ScalarFormatter(useMathText=plt.rcParams['text.usetex'])

def custom_corner(function):
    """
    A decorator function that customizes the corner plot generated by the input function.

    Parameters:
    - function: The function that generates the corner plot.

    Returns:
    - The customized corner plot.

    Usage:
    @custom_corner
    def generate_corner_plot(*args, **kwargs):
        # Code to generate the corner plot

    Example:
    generate_corner_plot(data, labels=['x', 'y', 'z'], color='blue', save=True, filename='corner_plot.png')
    """
    
    @wraps(function)
    def wrapper(*args, **kwargs):
        """
        A wrapper function that customizes matplotlib settings and calls the specified function with the given arguments.

        Parameters:
        *args: positional arguments to be passed to the specified function.
        **kwargs: keyword arguments to be passed to the specified function.

        Returns:
        fig: the figure object returned by the specified function.

        Raises:
        None.
        """

        corner_rcParams = {
            'xtick.top': False,
            'xtick.major.size': 3.5,
            #'xtick.major.width': 1.,
            'xtick.minor.visible': False,
            'xtick.direction': 'out',
            'ytick.right': False,
            'ytick.major.size': 3.5,
            #'ytick.major.width': 1.,
            'ytick.minor.visible': False,
            'ytick.direction': 'out',
            'ytick.labelsize': 'medium',
            'lines.linewidth': 1.5,
            }
        
        backcolor = plt.rcParams['figure.facecolor']
        frontcolor = plt.rcParams['text.color']

        # customize matplotlib
        if 'custom_rc' in kwargs.keys():
            custom_rc = kwargs.pop('custom_rc')
        else:
            custom_rc = True
        if custom_rc:
            plt.rcParams.update(corner_rcParams)

        if 'rcParams' in kwargs.keys():
            rcParams = kwargs.pop('rcParams')
            plt.rcParams.update(rcParams)

        defaults_kwargs = dict(
            bins=50, 
            smooth=0.5,
            title_kwargs=dict(fontsize=16), 
            color='#3f90da',
            truth_color=frontcolor,
            quantiles=[0.05, 0.5, 0.95],
            linestyle='-',
            plot_median=False,
            marginal_type='hist',
            quantiles_color=None, 
            show_titles = True, 
            title_fmt='.2e',
            levels=(1 - np.exp(-0.5), 1 - np.exp(-2), 1 - np.exp(-9 / 2.)),
            plot_density=False, 
            plot_datapoints=False, 
            fill_contours=True,
            max_n_ticks=5, 
            use_math_text=True, 
            custom_whspace=0.05,
        )

        
        _kwargs = kwargs.copy()
        
        save = False
        if 'save' in kwargs.keys():
            #save = True
            save = kwargs.pop('save')
            try:
                filename = kwargs.pop('filename')
            except:
                print('"filename" not provided, defaulted to cornerplot.pdf')
                filename = './cornerplot'

        hist_kwargs = dict(
                    histtype = _kwargs['histtype'] if 'histtype' in _kwargs.keys() else 'step',
                    edgecolor = _kwargs['color'] if 'color' in _kwargs.keys() else defaults_kwargs['color'],
                    lw = 1.5,
                    density=True, 
                )
        
        keys = _kwargs.keys()
        for key in keys:
            if key in defaults_kwargs.keys():
                defaults_kwargs.pop(key)

            if key in hist_kwargs.keys():
                hist_kwargs[key] = kwargs.pop(key)
            
        alpha = _kwargs['histalpha'] if 'histalpha' in _kwargs.keys() else 0.1
        defaults_kwargs.update(kwargs)
        fc = to_rgba(defaults_kwargs['color'], alpha=alpha)
        hist_kwargs['fc'] = fc
        defaults_kwargs['hist_kwargs'] = hist_kwargs
        kwargs = defaults_kwargs

        fig = function(*args, **kwargs)

        if save:
            fig.savefig(filename)
        
        default_plotting(backcolor=backcolor, frontcolor=frontcolor)

        return fig

    return wrapper

@custom_corner
def corner(*args, **kwargs):
    fig =  c.corner(*args, **kwargs)
    return fig

def set_color_cycle_from_cmap(cmap=None):
    '''
    use custom colormap as standard colorcycle. 
    '''
    if cmap:
        plt.rcParams["axes.prop_cycle"] = plt.cycler("color", cmap.colors)
    else:
         plt.rcParams["axes.prop_cycle"] =  plt.rcParamsDefault["axes.prop_cycle"]
    
def get_colors_from_cmap(N, cmap='viridis', reverse=False):
    cmap = mpl.colormaps[cmap]
    colors = cmap(np.linspace(0.3, 1., N))
    if reverse:
        colors = colors[::-1]
    return colors

def custom_color_cycle(colors='colors6', linestyles=['-'], skip=0, lsfirst=False):
    '''
    setup a custom matplotlib color cycler.
    `colors6`, `colors8`, `colors10` refer to the results of arXiv:2107.02270.
    `fancy` contains a color palette I like (still work in progress).
    '''

    baselinestyles = ['-', '--', '-.', ':']

    if isinstance(colors, str):
        colors = get_colorslist(colors)

    elif isinstance(colors, list):
        pass
    else:
        raise ValueError('provide `colors` as a list of color IDs or a key of `basecolors`')
    
    if isinstance(linestyles, int):
        linestyles = baselinestyles[:linestyles]
    
    if colors is not None:
        if lsfirst:
            mycycler = cycler(color=colors[skip:]) * cycler(linestyle=linestyles)
        else:
            mycycler = cycler(linestyle=linestyles) * cycler(color=colors[skip:])

        plt.rcParams["axes.prop_cycle"] =  mycycler
    
    else:
        plt.rcParams["axes.prop_cycle"] =  plt.rcParamsDefault["axes.prop_cycle"]


def get_colorslist(colors='colors6'):
    basecolors = {
        'colors6': ["#5790fc", "#f89c20", "#e42536", "#964a8b", "#9c9ca1", "#7a21dd"],
        'colors8': ["#1845fb", "#ff5e02", "#c91f16", "#c849a9", "#adad7d", "#86c8dd", "#578dff", "#656364"],
        'colors10': ["#3f90da", "#ffa90e", "#bd1f01", "#94a4a2", "#832db6", "#a96b59", "#e76300", "#b9ac70", "#717581", "#92dadd"],
        'fancy': ['#1c161c', '#324b58', '#088395', '#8ac5ad', '#a1f5a8']
    }

    assert colors in basecolors.keys()
    return basecolors[colors]


def to_pandas(samples, labels):
    """
    Converts the samples to a pandas DataFrame.

    Parameters:
    - samples (array): The samples to convert.
    - labels (list): The labels for the samples.

    Returns:
    - df (DataFrame): The samples as a pandas DataFrame.
    """
    df = pd.DataFrame(samples, columns=labels)
    return df

def chainplot(dfs, names=None, columns=None, truths=None, plot_dir='./', savename=None, fontsize=18, ticksize=14, ls=None, offset=True, chain_kwargs={}, chainconfig_kwargs={}, legend_kwargs={}, plotconfig_kwargs={}):
    """
    Plot chains of samples using ChainConsumer library.

    Parameters:
    - dfs (list or dict): List of pandas DataFrames or dictionary of pandas DataFrames containing the samples for each chain.
    - names (list or str, optional): List of names for each chain. If not provided, names will be automatically assigned.
    - columns (int or list, optional): Number of columns to include in the plot or list of column names to include. Default is None, which includes all columns.
    - truths (array-like, optional): Array-like object containing the true values to be plotted as a reference line. Default is None.
    - plot_dir (str, optional): Directory to save the plot. Default is './'.
    - savename (str, optional): Name of the saved plot file. If not provided, the plot will be displayed instead of saved.
    - fontsize (int, optional): Font size for the plot. Default is 18.
    - ticksize (int, optional): Font size for the tick labels. Default is 14.
    - ls (str, optional): Line style for the chains. Default is None. If not provided, the line style will be automatically assigned to be different for each dataframe.
    - offset (bool, optional): Whether to offset the chains vertically. Default is True.
    - chain_kwargs (dict, optional): Additional keyword arguments to be passed to the ChainConsumer.Chain constructor.
    - chainconfig_kwargs (dict, optional): Additional keyword arguments to be passed to the ChainConsumer.ChainConfig constructor.
    - legend_kwargs (dict, optional): Additional keyword arguments to be passed to the legend configuration.
    - plotconfig_kwargs (dict, optional): Additional keyword arguments to be passed to the plot configuration.

    Returns:
    - C (ChainConsumer): The ChainConsumer object containing the chains.
    - fig (matplotlib.figure.Figure): The matplotlib figure object.

    """

    if not isinstance(dfs, list):
        
        if isinstance(dfs, dict):
            names = list(dfs.keys())
            dfs = list(dfs.values())
        else:
            names = [names]
            dfs = [dfs]
        
    n_chains = len(dfs)

    lss = ["-", "--", "-.", ":"] if ls is None else [ls] * n_chains
    my_colorlists = ['colors6', 'colors8', 'colors10']
    colorstring = 'colors6'
    colors = get_colorslist(colors=colorstring) #TODO add flexibility for colors

    while n_chains > len(colors):
        #locate
        idx_now = my_colorlists.index(colorstring)
        if idx_now < len(my_colorlists) + 1:
            colorstring = my_colorlists[idx_now + 1]
            colors = get_colorslist(colors=colorstring)
        else:
            #restore default matplotlib color cycle
            colors = get_colors_from_cmap(n_chains, cmap='gist_rainbow')
    while n_chains > len(lss):
        lss = lss + lss


    C = chainconsumer.ChainConsumer()

    for i, name, df in zip(range(n_chains), names, dfs):

        if columns is None:
            columns_here = df.columns
        elif isinstance(columns, int):
            columns_here = df.columns[:columns]
        elif isinstance(columns, list):
            if isinstance(columns[0], list):
                # different columns for each chain
                columns_here = columns[i]
            else:
                # same columns for all chains
                columns_here = columns
        else:
            raise ValueError("columns must be None, int or list")


        chain = chainconsumer.Chain(samples=df[columns_here], name=name, linewidth=2.0, color=colors[i], linestyle=lss[i], **chain_kwargs)
        C.add_chain(chain)

    if truths is not None:
        C.add_truth(chainconsumer.Truth(location=truths, color='k', line_style="-", name="Injection"))
    #c.add_marker(location=df_truths[plotting_columns[:-1]], color='k', marker_style='x', marker_size=20, name="Injection")

    default_chain_kwargs = {
        "sigmas":[0, 1, 2],
        "shade_gradient": 1,
        "shade_alpha": 0.5,
        "statistics": "cumulative",
        "summary_area": 0.90,
    }

    chainconfig_kwargs = default_chain_kwargs | chainconfig_kwargs

    default_legend_kwargs = {
        "labelspacing": 0.8,
        "loc": "center left",
        "frameon": True,
        "fontsize": fontsize,
        "handlelength": 1.5,
        "handletextpad": 0.5,
        "borderaxespad": 0.0,
        }
    
    legend_kwargs = default_legend_kwargs | legend_kwargs
    
    default_plot_kwargs = {
        "summarise": True,
        "tick_font_size": ticksize,
        "label_font_size": fontsize,
        "summary_font_size": fontsize,
        "contour_label_font_size": fontsize,
        "diagonal_tick_labels": True,
        "spacing":None,
        "usetex": True,
        "serif": True,
        "dpi": 300,
        "legend_kwargs": legend_kwargs,
        "legend_color_text": False,
        "show_legend": True,
    }

    plotconfig_kwargs = default_plot_kwargs | plotconfig_kwargs

    C.set_override(chainconsumer.ChainConfig(**chainconfig_kwargs))
    C.set_plot_config(chainconsumer.PlotConfig(**plotconfig_kwargs))

    fig = C.plotter.plot(offset=offset)
    axes = fig.get_axes()
    for ax in axes:
        x_range = ax.get_xlim()
        y_range = ax.get_ylim()

        # If the axis range is very small (e.g., close to 1e-15), use scientific notation
        if abs(x_range[1] - x_range[0]) < 1e-3 or abs(y_range[1] - y_range[0]) < 1e-3:
            ax.ticklabel_format(style='scientific', axis='both', scilimits=(-3, 3))
        else:
            ax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%.2f'))
            ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.2f'))

        # Set the label coordinates for consistent alignment
        ax.xaxis.set_label_coords(0.5, -0.32)  # Adjust x-label position (relative to axis)
        ax.yaxis.set_label_coords(-0.32, 0.5)  # Adjust y-label position (relative to axis)



    #plt.tight_layout()
    if savename is not None:
        plt.savefig(plot_dir + savename + '.pdf', bbox_inches='tight')
        plt.close()
    # else:
    #     plt.show()

    return C, fig
